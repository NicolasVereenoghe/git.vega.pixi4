{"version":3,"file":"pixi-multistyle-text.m.js","sources":["../src/pixi-multistyle-text.ts"],"sourcesContent":["/// <reference types=\"pixi.js\" />\n\n\"use strict\";\n\nexport interface ExtendedTextStyle extends PIXI.TextStyleOptions {\n\tvalign?: \"top\" | \"middle\" | \"bottom\" | \"baseline\" | number;\n\tdebug?: boolean;\n}\n\nexport interface TextStyleSet {\n\t[key: string]: ExtendedTextStyle;\n}\n\ninterface FontProperties {\n\tascent: number;\n\tdescent: number;\n\tfontSize: number;\n}\n\ninterface TextData {\n\ttext: string;\n\tstyle: ExtendedTextStyle;\n\twidth: number;\n\theight: number;\n\tfontProperties: FontProperties;\n\ttag: TagData;\n}\n\ninterface TextDrawingData {\n\ttext: string;\n\tstyle: ExtendedTextStyle;\n\tx: number;\n\ty: number;\n\twidth: number;\n\tascent: number;\n\tdescent: number;\n\ttag: TagData;\n}\n\nexport interface MstDebugOptions {\n\tspans: {\n\t\tenabled?: boolean;\n\t\tbaseline?: string;\n\t\ttop?: string;\n\t\tbottom?: string;\n\t\tbounding?: string;\n\t\ttext?: boolean;\n\t};\n\tobjects: {\n\t\tenabled?: boolean;\n\t\tbounding?: string;\n\t\ttext?: boolean;\n\t}\n}\n\nexport interface TagData {\n\tname: string;\n\tproperties: { [key: string]: string };\n}\n\nexport interface MstInteractionEvent extends PIXI.interaction.InteractionEvent {\n\ttargetTag: TagData;\n}\n\nconst INTERACTION_EVENTS = [\n\t\"pointerover\",\n\t\"pointerenter\",\n\t\"pointerdown\",\n\t\"pointermove\",\n\t\"pointerup\",\n\t\"pointercancel\",\n\t\"pointerout\",\n\t\"pointerleave\",\n\t\"gotpointercapture\",\n\t\"lostpointercapture\",\n\t\"mouseover\",\n\t\"mouseenter\",\n\t\"mousedown\",\n\t\"mousemove\",\n\t\"mouseup\",\n\t\"mousecancel\",\n\t\"mouseout\",\n\t\"mouseleave\",\n\t\"touchover\",\n\t\"touchenter\",\n\t\"touchdown\",\n\t\"touchmove\",\n\t\"touchup\",\n\t\"touchcancel\",\n\t\"touchout\",\n\t\"touchleave\"\n];\n\nexport default class MultiStyleText extends PIXI.Text {\n\tprivate static DEFAULT_TAG_STYLE: ExtendedTextStyle = {\n\t\talign: \"left\",\n\t\tbreakWords: false,\n\t\t// debug intentionally not included\n\t\tdropShadow: false,\n\t\tdropShadowAngle: Math.PI / 6,\n\t\tdropShadowBlur: 0,\n\t\tdropShadowColor: \"#000000\",\n\t\tdropShadowDistance: 5,\n\t\tfill: \"black\",\n\t\tfillGradientType: PIXI.TEXT_GRADIENT.LINEAR_VERTICAL,\n\t\tfontFamily: \"Arial\",\n\t\tfontSize: 26,\n\t\tfontStyle: \"normal\",\n\t\tfontVariant: \"normal\",\n\t\tfontWeight: \"normal\",\n\t\tletterSpacing: 0,\n\t\tlineHeight: 0,\n\t\tlineJoin: \"miter\",\n\t\tmiterLimit: 10,\n\t\tpadding: 0,\n\t\tstroke: \"black\",\n\t\tstrokeThickness: 0,\n\t\ttextBaseline: \"alphabetic\",\n\t\tvalign: \"baseline\",\n\t\twordWrap: false,\n\t\twordWrapWidth: 100\n\t};\n\n\tpublic static debugOptions: MstDebugOptions = {\n\t\tspans: {\n\t\t\tenabled: false,\n\t\t\tbaseline: \"#44BB44\",\n\t\t\ttop: \"#BB4444\",\n\t\t\tbottom: \"#4444BB\",\n\t\t\tbounding: \"rgba(255, 255, 255, 0.1)\",\n\t\t\ttext: true\n\t\t},\n\t\tobjects: {\n\t\t\tenabled: false,\n\t\t\tbounding: \"rgba(255, 255, 255, 0.05)\",\n\t\t\ttext: true\n\t\t}\n\t};\n\n\tprivate textStyles: TextStyleSet;\n\n\tprivate hitboxes: { tag: TagData, hitbox: PIXI.Rectangle }[];\n\n\tconstructor(text: string, styles: TextStyleSet) {\n\t\tsuper(text);\n\n\t\tthis.styles = styles;\n\n\t\tINTERACTION_EVENTS.forEach((event) => {\n\t\t\tthis.on(event, (e: PIXI.interaction.InteractionEvent) => this.handleInteraction(e));\n\t\t});\n\t}\n\n\tprivate handleInteraction(e: PIXI.interaction.InteractionEvent) {\n\t\tlet ev = e as MstInteractionEvent;\n\n\t\tlet localPoint = e.data.getLocalPosition(this);\n\t\tlet targetTag = this.hitboxes.reduce((prev, hitbox) => prev !== undefined ? prev : (hitbox.hitbox.contains(localPoint.x, localPoint.y) ? hitbox : undefined), undefined);\n\t\tev.targetTag = targetTag === undefined ? undefined : targetTag.tag;\n\t}\n\n\tpublic set styles(styles: TextStyleSet) {\n\t\tthis.textStyles = {};\n\n\t\tthis.textStyles[\"default\"] = this.assign({}, MultiStyleText.DEFAULT_TAG_STYLE);\n\n\t\tfor (let style in styles) {\n\t\t\tif (style === \"default\") {\n\t\t\t\tthis.assign(this.textStyles[\"default\"], styles[style]);\n\t\t\t} else {\n\t\t\t\tthis.textStyles[style] = this.assign({}, styles[style]);\n\t\t\t}\n\t\t}\n\n\t\tthis._style = new PIXI.TextStyle(this.textStyles[\"default\"]);\n\t\tthis.dirty = true;\n\t}\n\n\tpublic setTagStyle(tag: string, style: ExtendedTextStyle): void {\n\t\tif (tag in this.textStyles) {\n\t\t\tthis.assign(this.textStyles[tag], style);\n\t\t} else {\n\t\t\tthis.textStyles[tag] = this.assign({}, style);\n\t\t}\n\n\t\tthis._style = new PIXI.TextStyle(this.textStyles[\"default\"]);\n\t\tthis.dirty = true;\n\t}\n\n\tpublic deleteTagStyle(tag: string): void {\n\t\tif (tag === \"default\") {\n\t\t\tthis.textStyles[\"default\"] = this.assign({}, MultiStyleText.DEFAULT_TAG_STYLE);\n\t\t} else {\n\t\t\tdelete this.textStyles[tag];\n\t\t}\n\n\t\tthis._style = new PIXI.TextStyle(this.textStyles[\"default\"]);\n\t\tthis.dirty = true;\n\t}\n\n\tprivate getTagRegex(captureName: boolean, captureMatch: boolean): RegExp {\n\t\tlet tagAlternation = Object.keys(this.textStyles).join(\"|\");\n\n\t\tif (captureName) {\n\t\t\ttagAlternation = `(${tagAlternation})`;\n\t\t} else {\n\t\t\ttagAlternation = `(?:${tagAlternation})`;\n\t\t}\n\n\t\tlet reStr = `<${tagAlternation}(?:\\\\s+[A-Za-z0-9_\\\\-]+=(?:\"(?:[^\"]+|\\\\\\\\\")*\"|'(?:[^']+|\\\\\\\\')*'))*\\\\s*>|</${tagAlternation}\\\\s*>`;\n\n\t\tif (captureMatch) {\n\t\t\treStr = `(${reStr})`;\n\t\t}\n\n\t\treturn new RegExp(reStr, \"g\");\n\t}\n\n\tprivate getPropertyRegex(): RegExp {\n\t\treturn new RegExp(`([A-Za-z0-9_\\\\-]+)=(?:\"((?:[^\"]+|\\\\\\\\\")*)\"|'((?:[^']+|\\\\\\\\')*)')`, \"g\");\n\t}\n\n\tprivate _getTextDataPerLine (lines: string[]) {\n\t\tlet outputTextData: TextData[][] = [];\n\t\tlet re = this.getTagRegex(true, false);\n\n\t\tlet styleStack = [this.assign({}, this.textStyles[\"default\"])];\n\t\tlet tagStack: TagData[] = [{ name: \"default\", properties: {} }];\n\n\t\t// determine the group of word for each line\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tlet lineTextData: TextData[] = [];\n\n\t\t\t// find tags inside the string\n\t\t\tlet matches: RegExpExecArray[] = [];\n\t\t\tlet matchArray: RegExpExecArray;\n\n\t\t\twhile (matchArray = re.exec(lines[i])) {\n\t\t\t\tmatches.push(matchArray);\n\t\t\t}\n\n\t\t\t// if there is no match, we still need to add the line with the default style\n\t\t\tif (matches.length === 0) {\n\t\t\t\tlineTextData.push(this.createTextData(lines[i], styleStack[styleStack.length - 1], tagStack[tagStack.length - 1]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We got a match! add the text with the needed style\n\t\t\t\tlet currentSearchIdx = 0;\n\t\t\t\tfor (let j = 0; j < matches.length; j++) {\n\t\t\t\t\t// if index > 0, it means we have characters before the match,\n\t\t\t\t\t// so we need to add it with the default style\n\t\t\t\t\tif (matches[j].index > currentSearchIdx) {\n\t\t\t\t\t\tlineTextData.push(this.createTextData(\n\t\t\t\t\t\t\tlines[i].substring(currentSearchIdx, matches[j].index),\n\t\t\t\t\t\t\tstyleStack[styleStack.length - 1],\n\t\t\t\t\t\t\ttagStack[tagStack.length - 1]\n\t\t\t\t\t\t));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (matches[j][0][1] === \"/\") { // reset the style if end of tag\n\t\t\t\t\t\tif (styleStack.length > 1) {\n\t\t\t\t\t\t\tstyleStack.pop();\n\t\t\t\t\t\t\ttagStack.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { // set the current style\n\t\t\t\t\t\tstyleStack.push(this.assign({}, styleStack[styleStack.length - 1], this.textStyles[matches[j][1]]));\n\n\t\t\t\t\t\tlet properties: { [key: string]: string } = {};\n\t\t\t\t\t\tlet propertyRegex = this.getPropertyRegex();\n\t\t\t\t\t\tlet propertyMatch: RegExpMatchArray;\n\n\t\t\t\t\t\twhile (propertyMatch = propertyRegex.exec(matches[j][0])) {\n\t\t\t\t\t\t\tproperties[propertyMatch[1]] = propertyMatch[2] || propertyMatch[3];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttagStack.push({ name: matches[j][1], properties });\n\t\t\t\t\t}\n\n\t\t\t\t\t// update the current search index\n\t\t\t\t\tcurrentSearchIdx = matches[j].index + matches[j][0].length;\n\t\t\t\t}\n\n\t\t\t\t// is there any character left?\n\t\t\t\tif (currentSearchIdx < lines[i].length) {\n\t\t\t\t\tlineTextData.push(this.createTextData(\n\t\t\t\t\t\tlines[i].substring(currentSearchIdx),\n\t\t\t\t\t\tstyleStack[styleStack.length - 1],\n\t\t\t\t\t\ttagStack[tagStack.length - 1]\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toutputTextData.push(lineTextData);\n\t\t}\n\n\t\treturn outputTextData;\n\t}\n\n\tprivate getFontString(style: ExtendedTextStyle): string {\n\t\treturn new PIXI.TextStyle(style).toFontString();\n\t}\n\n\tprivate createTextData(text: string, style: ExtendedTextStyle, tag: TagData): TextData {\n\t\treturn {\n\t\t\ttext,\n\t\t\tstyle,\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\tfontProperties: undefined,\n\t\t\ttag\n\t\t};\n\t}\n\n\tprivate getDropShadowPadding(): number {\n\t\tlet maxDistance = 0;\n\t\tlet maxBlur = 0;\n\n\t\t Object.keys(this.textStyles).forEach((styleKey) => {\n\t\t\tlet { dropShadowDistance, dropShadowBlur } = this.textStyles[styleKey];\n\t\t\tmaxDistance = Math.max(maxDistance, dropShadowDistance || 0);\n\t\t\tmaxBlur = Math.max(maxBlur, dropShadowBlur || 0);\n\t\t});\n\n\t\treturn maxDistance + maxBlur;\n\t}\n\n\tpublic updateText(): void {\n\t\tif (!this.dirty) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.hitboxes = [];\n\n\t\tthis.texture.baseTexture.resolution = this.resolution;\n\t\tlet textStyles = this.textStyles;\n\t\tlet outputText = this.text;\n\n\t\tif(this._style.wordWrap) {\n\t\t\toutputText = this.wordWrap(this.text);\n\t\t}\n\n\t\t// split text into lines\n\t\tlet lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n\n\t\t// get the text data with specific styles\n\t\tlet outputTextData = this._getTextDataPerLine(lines);\n\n\t\t// calculate text width and height\n\t\tlet lineWidths: number[] = [];\n\t\tlet lineYMins: number[] = [];\n\t\tlet lineYMaxs: number[] = [];\n\t\tlet baselines: number[] = [];\n\t\tlet maxLineWidth = 0;\n\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tlet lineWidth = 0;\n\t\t\tlet lineYMin = 0;\n\t\t\tlet lineYMax = 0;\n\t\t\tlet baseline = 0;\n\t\t\tfor (let j = 0; j < outputTextData[i].length; j++) {\n\t\t\t\tlet sty = outputTextData[i][j].style;\n\n\t\t\t\tthis.context.font = this.getFontString(sty);\n\n\t\t\t\t// save the width\n\t\t\t\toutputTextData[i][j].width = this.context.measureText(outputTextData[i][j].text).width;\n\n\t\t\t\tif (outputTextData[i][j].text.length === 0) {\n\t\t\t\t\toutputTextData[i][j].width += (outputTextData[i][j].text.length - 1) * sty.letterSpacing;\n\n\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\tlineWidth += sty.letterSpacing / 2; // spacing before first character\n\t\t\t\t\t}\n\n\t\t\t\t\tif (j < outputTextData[i].length - 1) {\n\t\t\t\t\t\tlineWidth += sty.letterSpacing / 2; // spacing after last character\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlineWidth += outputTextData[i][j].width;\n\n\t\t\t\t// save the font properties\n\t\t\t\toutputTextData[i][j].fontProperties = PIXI.TextMetrics.measureFont(this.context.font);\n\n\t\t\t\t// save the height\n\t\t\t\toutputTextData[i][j].height =\n\t\t\t\t\t\toutputTextData[i][j].fontProperties.fontSize + outputTextData[i][j].style.strokeThickness;\n\n\t\t\t\tif (typeof sty.valign === \"number\") {\n\t\t\t\t\tlineYMin = Math.min(lineYMin, sty.valign - outputTextData[i][j].fontProperties.descent);\n\t\t\t\t\tlineYMax = Math.max(lineYMax, sty.valign + outputTextData[i][j].fontProperties.ascent);\n\t\t\t\t} else {\n\t\t\t\t\tlineYMin = Math.min(lineYMin, -outputTextData[i][j].fontProperties.descent);\n\t\t\t\t\tlineYMax = Math.max(lineYMax, outputTextData[i][j].fontProperties.ascent);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlineWidths[i] = lineWidth;\n\t\t\tlineYMins[i] = lineYMin;\n\t\t\tlineYMaxs[i] = lineYMax;\n\t\t\tmaxLineWidth = Math.max(maxLineWidth, lineWidth);\n\t\t}\n\n\t\t// transform styles in array\n\t\tlet stylesArray = Object.keys(textStyles).map((key) => textStyles[key]);\n\n\t\tlet maxStrokeThickness = stylesArray.reduce((prev, cur) => Math.max(prev, cur.strokeThickness || 0), 0);\n\n\t\tlet dropShadowPadding = this.getDropShadowPadding();\n\n\t\tlet totalHeight = lineYMaxs.reduce((prev, cur) => prev + cur, 0) - lineYMins.reduce((prev, cur) => prev + cur, 0);\n\n\t\t// define the right width and height\n\t\tlet width = maxLineWidth + maxStrokeThickness + 2 * dropShadowPadding;\n\t\tlet height = totalHeight + 2 * dropShadowPadding;\n\n\t\tthis.canvas.width = (width + this.context.lineWidth) * this.resolution;\n\t\tthis.canvas.height = height * this.resolution;\n\n\t\tthis.context.scale(this.resolution, this.resolution);\n\n\t\tthis.context.textBaseline = \"alphabetic\";\n\t\tthis.context.lineJoin = \"round\";\n\n\t\tlet basePositionY = dropShadowPadding;\n\n\t\tlet drawingData: TextDrawingData[] = [];\n\n\t\t// Compute the drawing data\n\t\tfor (let i = 0; i < outputTextData.length; i++) {\n\t\t\tlet line = outputTextData[i];\n\t\t\tlet linePositionX: number;\n\n\t\t\tswitch (this._style.align) {\n\t\t\t\tcase \"left\":\n\t\t\t\t\tlinePositionX = dropShadowPadding;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"center\":\n\t\t\t\t\tlinePositionX = dropShadowPadding + (maxLineWidth - lineWidths[i]) / 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"right\":\n\t\t\t\t\tlinePositionX = dropShadowPadding + maxLineWidth - lineWidths[i];\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (let j = 0; j < line.length; j++) {\n\t\t\t\tlet { style, text, fontProperties, width, height, tag } = line[j];\n\n\t\t\t\tlinePositionX += maxStrokeThickness / 2;\n\n\t\t\t\tlet linePositionY = maxStrokeThickness / 2 + basePositionY + fontProperties.ascent;\n\n\t\t\t\tswitch (style.valign) {\n\t\t\t\t\tcase \"top\":\n\t\t\t\t\t\t// no need to do anything\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"baseline\":\n\t\t\t\t\t\tlinePositionY += lineYMaxs[i] - fontProperties.ascent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"middle\":\n\t\t\t\t\t\tlinePositionY += (lineYMaxs[i] - lineYMins[i] - fontProperties.ascent - fontProperties.descent) / 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"bottom\":\n\t\t\t\t\t\tlinePositionY += lineYMaxs[i] - lineYMins[i] - fontProperties.ascent - fontProperties.descent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// A number - offset from baseline, positive is higher\n\t\t\t\t\t\tlinePositionY += lineYMaxs[i] - fontProperties.ascent - style.valign;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (style.letterSpacing === 0) {\n\t\t\t\t\tdrawingData.push({\n\t\t\t\t\t\ttext,\n\t\t\t\t\t\tstyle,\n\t\t\t\t\t\tx: linePositionX,\n\t\t\t\t\t\ty: linePositionY,\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\tascent: fontProperties.ascent,\n\t\t\t\t\t\tdescent: fontProperties.descent,\n\t\t\t\t\t\ttag\n\t\t\t\t\t});\n\n\t\t\t\t\tlinePositionX += line[j].width;\n\t\t\t\t} else {\n\t\t\t\t\tthis.context.font = this.getFontString(line[j].style);\n\n\t\t\t\t\tfor (let k = 0; k < text.length; k++) {\n\t\t\t\t\t\tif (k > 0 || j > 0) {\n\t\t\t\t\t\t\tlinePositionX += style.letterSpacing / 2;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdrawingData.push({\n\t\t\t\t\t\t\ttext: text.charAt(k),\n\t\t\t\t\t\t\tstyle,\n\t\t\t\t\t\t\tx: linePositionX,\n\t\t\t\t\t\t\ty: linePositionY,\n\t\t\t\t\t\t\twidth,\n\t\t\t\t\t\t\tascent: fontProperties.ascent,\n\t\t\t\t\t\t\tdescent: fontProperties.descent,\n\t\t\t\t\t\t\ttag\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tlinePositionX += this.context.measureText(text.charAt(k)).width;\n\n\t\t\t\t\t\tif (k < text.length - 1 || j < line.length - 1) {\n\t\t\t\t\t\t\tlinePositionX += style.letterSpacing / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlinePositionX -= maxStrokeThickness / 2;\n\t\t\t}\n\n\t\t\tbasePositionY += lineYMaxs[i] - lineYMins[i];\n\t\t}\n\n\t\tthis.context.save();\n\n\t\t// First pass: draw the shadows only\n\t\tdrawingData.forEach(({ style, text, x, y }) => {\n\t\t\tif (!style.dropShadow) {\n\t\t\t\treturn; // This text doesn't have a shadow\n\t\t\t}\n\n\t\t\tthis.context.font = this.getFontString(style);\n\n\t\t\tlet dropFillStyle = style.dropShadowColor;\n\t\t\tif (typeof dropFillStyle === \"number\") {\n\t\t\t\tdropFillStyle = PIXI.utils.hex2string(dropFillStyle);\n\t\t\t}\n\t\t\tthis.context.shadowColor = dropFillStyle;\n\t\t\tthis.context.shadowBlur = style.dropShadowBlur;\n\t\t\tthis.context.shadowOffsetX = Math.cos(style.dropShadowAngle) * style.dropShadowDistance * this.resolution;\n\t\t\tthis.context.shadowOffsetY = Math.sin(style.dropShadowAngle) * style.dropShadowDistance * this.resolution;\n\n\t\t\tthis.context.fillText(text, x, y);\n\t\t});\n\n\t\tthis.context.restore();\n\n\t\t// Second pass: draw strokes and fills\n\t\tdrawingData.forEach(({ style, text, x, y, width, ascent, descent, tag }) => {\n\t\t\tthis.context.font = this.getFontString(style);\n\n\t\t\tlet strokeStyle = style.stroke;\n\t\t\tif (typeof strokeStyle === \"number\") {\n\t\t\t\tstrokeStyle = PIXI.utils.hex2string(strokeStyle);\n\t\t\t}\n\n\t\t\tthis.context.strokeStyle = strokeStyle;\n\t\t\tthis.context.lineWidth = style.strokeThickness;\n\n\t\t\t// set canvas text styles\n\t\t\tlet fillStyle = style.fill;\n\t\t\tif (typeof fillStyle === \"number\") {\n\t\t\t\tfillStyle = PIXI.utils.hex2string(fillStyle);\n\t\t\t} else if (Array.isArray(fillStyle)) {\n\t\t\t\tfor (let i = 0; i < fillStyle.length; i++) {\n\t\t\t\t\tlet fill = fillStyle[i];\n\t\t\t\t\tif (typeof fill === \"number\") {\n\t\t\t\t\t\tfillStyle[i] = PIXI.utils.hex2string(fill);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.context.fillStyle = this._generateFillStyle(new PIXI.TextStyle(style), [text]) as string | CanvasGradient;\n\t\t\t// Typecast required for proper typechecking\n\n\t\t\tif (style.stroke && style.strokeThickness) {\n\t\t\t\tthis.context.strokeText(text, x, y);\n\t\t\t}\n\n\t\t\tif (style.fill) {\n\t\t\t\tthis.context.fillText(text, x, y);\n\t\t\t}\n\n\t\t\tlet offset = -this._style.padding - this.getDropShadowPadding();\n\n\t\t\tthis.hitboxes.push({\n\t\t\t\ttag,\n\t\t\t\thitbox: new PIXI.Rectangle(x + offset, y - ascent + offset, width, ascent + descent)\n\t\t\t});\n\n\t\t\tlet debugSpan = style.debug === undefined\n\t\t\t\t? MultiStyleText.debugOptions.spans.enabled\n\t\t\t\t: style.debug;\n\n\t\t\tif (debugSpan) {\n\t\t\t\tthis.context.lineWidth = 1;\n\n\t\t\t\tif (MultiStyleText.debugOptions.spans.bounding) {\n\t\t\t\t\tthis.context.fillStyle = MultiStyleText.debugOptions.spans.bounding;\n\t\t\t\t\tthis.context.strokeStyle = MultiStyleText.debugOptions.spans.bounding;\n\t\t\t\t\tthis.context.beginPath();\n\t\t\t\t\tthis.context.rect(x, y - ascent, width, ascent + descent);\n\t\t\t\t\tthis.context.fill();\n\t\t\t\t\tthis.context.stroke();\n\t\t\t\t\tthis.context.stroke(); // yes, twice\n\t\t\t\t}\n\n\t\t\t\tif (MultiStyleText.debugOptions.spans.baseline) {\n\t\t\t\t\tthis.context.strokeStyle = MultiStyleText.debugOptions.spans.baseline;\n\t\t\t\t\tthis.context.beginPath();\n\t\t\t\t\tthis.context.moveTo(x, y);\n\t\t\t\t\tthis.context.lineTo(x + width, y);\n\t\t\t\t\tthis.context.closePath();\n\t\t\t\t\tthis.context.stroke();\n\t\t\t\t}\n\n\t\t\t\tif (MultiStyleText.debugOptions.spans.top) {\n\t\t\t\t\tthis.context.strokeStyle = MultiStyleText.debugOptions.spans.top;\n\t\t\t\t\tthis.context.beginPath();\n\t\t\t\t\tthis.context.moveTo(x, y - ascent);\n\t\t\t\t\tthis.context.lineTo(x + width, y - ascent);\n\t\t\t\t\tthis.context.closePath();\n\t\t\t\t\tthis.context.stroke();\n\t\t\t\t}\n\n\t\t\t\tif (MultiStyleText.debugOptions.spans.bottom) {\n\t\t\t\t\tthis.context.strokeStyle = MultiStyleText.debugOptions.spans.bottom;\n\t\t\t\t\tthis.context.beginPath();\n\t\t\t\t\tthis.context.moveTo(x, y + descent);\n\t\t\t\t\tthis.context.lineTo(x + width, y + descent);\n\t\t\t\t\tthis.context.closePath();\n\t\t\t\t\tthis.context.stroke();\n\t\t\t\t}\n\n\t\t\t\tif (MultiStyleText.debugOptions.spans.text) {\n\t\t\t\t\tthis.context.fillStyle = \"#ffffff\";\n\t\t\t\t\tthis.context.strokeStyle = \"#000000\";\n\t\t\t\t\tthis.context.lineWidth = 2;\n\t\t\t\t\tthis.context.font = \"8px monospace\";\n\t\t\t\t\tthis.context.strokeText(tag.name, x, y - ascent + 8);\n\t\t\t\t\tthis.context.fillText(tag.name, x, y - ascent + 8);\n\t\t\t\t\tthis.context.strokeText(`${width.toFixed(2)}x${(ascent + descent).toFixed(2)}`, x, y - ascent + 16);\n\t\t\t\t\tthis.context.fillText(`${width.toFixed(2)}x${(ascent + descent).toFixed(2)}`, x, y - ascent + 16);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (MultiStyleText.debugOptions.objects.enabled) {\n\t\t\tif (MultiStyleText.debugOptions.objects.bounding) {\n\t\t\t\tthis.context.fillStyle = MultiStyleText.debugOptions.objects.bounding;\n\t\t\t\tthis.context.beginPath();\n\t\t\t\tthis.context.rect(0, 0, width, height);\n\t\t\t\tthis.context.fill();\n\t\t\t}\n\n\t\t\tif (MultiStyleText.debugOptions.objects.text) {\n\t\t\t\tthis.context.fillStyle = \"#ffffff\";\n\t\t\t\tthis.context.strokeStyle = \"#000000\";\n\t\t\t\tthis.context.lineWidth = 2;\n\t\t\t\tthis.context.font = \"8px monospace\";\n\t\t\t\tthis.context.strokeText(`${width.toFixed(2)}x${height.toFixed(2)}`, 0, 8, width);\n\t\t\t\tthis.context.fillText(`${width.toFixed(2)}x${height.toFixed(2)}`, 0, 8, width);\n\t\t\t}\n\t\t}\n\n\t\tthis.updateTexture();\n\t}\n\n\tprotected wordWrap(text: string): string {\n\t\t// Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal bounds.\n\t\tlet result = \"\";\n\t\tlet re = this.getTagRegex(true, true);\n\n\t\tconst lines = text.split(\"\\n\");\n\t\tconst wordWrapWidth = this._style.wordWrapWidth;\n\t\tlet styleStack = [this.assign({}, this.textStyles[\"default\"])];\n\t\tthis.context.font = this.getFontString(this.textStyles[\"default\"]);\n\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tlet spaceLeft = wordWrapWidth;\n\t\t\tconst tagSplit = lines[i].split(re);\n\t\t\tlet firstWordOfLine = true;\n\n\t\t\tfor (let j = 0; j < tagSplit.length; j++) {\n\t\t\t\tif (re.test(tagSplit[j])) {\n\t\t\t\t\tresult += tagSplit[j];\n\t\t\t\t\tif (tagSplit[j][1] === \"/\") {\n\t\t\t\t\t\tj += 2;\n\t\t\t\t\t\tstyleStack.pop();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tstyleStack.push(this.assign({}, styleStack[styleStack.length - 1], this.textStyles[tagSplit[j]]));\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tthis.context.font = this.getFontString(styleStack[styleStack.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tconst words = tagSplit[j].split(\" \");\n\n\t\t\t\t\tfor (let k = 0; k < words.length; k++) {\n\t\t\t\t\t\tconst wordWidth = this.context.measureText(words[k]).width;\n\n\t\t\t\t\t\tif (this._style.breakWords && wordWidth > spaceLeft) {\n\t\t\t\t\t\t\t// Part should be split in the middle\n\t\t\t\t\t\t\tconst characters = words[k].split('');\n\n\t\t\t\t\t\t\tif (k > 0) {\n\t\t\t\t\t\t\t\tresult += \" \";\n\t\t\t\t\t\t\t\tspaceLeft -= this.context.measureText(\" \").width;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor (let c = 0; c < characters.length; c++) {\n\t\t\t\t\t\t\t\tconst characterWidth = this.context.measureText(characters[c]).width;\n\n\t\t\t\t\t\t\t\tif (characterWidth > spaceLeft) {\n\t\t\t\t\t\t\t\t\tresult += `\\n${characters[c]}`;\n\t\t\t\t\t\t\t\t\tspaceLeft = wordWrapWidth - characterWidth;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tresult += characters[c];\n\t\t\t\t\t\t\t\t\tspaceLeft -= characterWidth;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if(this._style.breakWords) {\n\t\t\t\t\t\t\tresult += words[k];\n\t\t\t\t\t\t\tspaceLeft -= wordWidth;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst paddedWordWidth =\n\t\t\t\t\t\t\t\twordWidth + (k > 0 ? this.context.measureText(\" \").width : 0);\n\n\t\t\t\t\t\t\tif (paddedWordWidth > spaceLeft) {\n\t\t\t\t\t\t\t\t// Skip printing the newline if it's the first word of the line that is\n\t\t\t\t\t\t\t\t// greater than the word wrap width.\n\t\t\t\t\t\t\t\tif (!firstWordOfLine) {\n\t\t\t\t\t\t\t\t\tresult += \"\\n\";\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tresult += words[k];\n\t\t\t\t\t\t\t\tspaceLeft = wordWrapWidth - wordWidth;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tspaceLeft -= paddedWordWidth;\n\n\t\t\t\t\t\t\t\tif (k > 0) {\n\t\t\t\t\t\t\t\t\tresult += \" \";\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tresult += words[k];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfirstWordOfLine = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i < lines.length - 1) {\n\t\t\t\tresult += '\\n';\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprotected updateTexture() {\n\t\tconst texture = this._texture;\n\n\t\tlet dropShadowPadding = this.getDropShadowPadding();\n\n\t\ttexture.baseTexture.hasLoaded = true;\n\t\ttexture.baseTexture.resolution = this.resolution;\n\n\t\ttexture.baseTexture.realWidth = this.canvas.width;\n\t\ttexture.baseTexture.realHeight = this.canvas.height;\n\t\ttexture.baseTexture.width = this.canvas.width / this.resolution;\n\t\ttexture.baseTexture.height = this.canvas.height / this.resolution;\n\t\ttexture.trim.width = texture.frame.width = this.canvas.width / this.resolution;\n\t\ttexture.trim.height = texture.frame.height = this.canvas.height / this.resolution;\n\n\t\ttexture.trim.x = -this._style.padding - dropShadowPadding;\n\t\ttexture.trim.y = -this._style.padding - dropShadowPadding;\n\n\t\ttexture.orig.width = texture.frame.width - (this._style.padding + dropShadowPadding) * 2;\n\t\ttexture.orig.height = texture.frame.height - (this._style.padding + dropShadowPadding) * 2;\n\n\t\t// call sprite onTextureUpdate to update scale if _width or _height were set\n\t\tthis._onTextureUpdate();\n\n\t\ttexture.baseTexture.emit('update', texture.baseTexture);\n\n\t\tthis.dirty = false;\n\t}\n\n\t// Lazy fill for Object.assign\n\tprivate assign(destination: any, ...sources: any[]): any {\n\t\tfor (let source of sources) {\n\t\t\tfor (let key in source) {\n\t\t\t\tdestination[key] = source[key];\n\t\t\t}\n\t\t}\n\n\t\treturn destination;\n\t}\n}\n"],"names":["INTERACTION_EVENTS","text","styles","_super","_this","forEach","event","on","e","handleInteraction","tslib_1.__extends","MultiStyleText","ev","localPoint","data","getLocalPosition","this","targetTag","hitboxes","reduce","prev","hitbox","undefined","contains","x","y","tag","Object","style","textStyles","assign","DEFAULT_TAG_STYLE","_style","PIXI","TextStyle","dirty","captureName","captureMatch","tagAlternation","keys","join","reStr","RegExp","lines","outputTextData","re","getTagRegex","styleStack","tagStack","name","properties","i","length","lineTextData","matches","matchArray","exec","push","createTextData","currentSearchIdx","j","index","substring","pop","propertyRegex","getPropertyRegex","propertyMatch","toFontString","width","height","fontProperties","maxDistance","maxBlur","styleKey","_a","dropShadowBlur","Math","max","texture","baseTexture","resolution","outputText","wordWrap","split","_getTextDataPerLine","lineWidths","lineYMins","lineYMaxs","maxLineWidth","lineWidth","lineYMin","lineYMax","sty","context","font","getFontString","measureText","letterSpacing","TextMetrics","measureFont","fontSize","strokeThickness","valign","min","descent","ascent","maxStrokeThickness","map","key","cur","dropShadowPadding","getDropShadowPadding","canvas","scale","textBaseline","lineJoin","basePositionY","drawingData","line","linePositionX","align","width_1","linePositionY","k","charAt","save","dropShadow","dropFillStyle","dropShadowColor","utils","hex2string","shadowColor","shadowBlur","shadowOffsetX","cos","dropShadowAngle","dropShadowDistance","shadowOffsetY","sin","fillText","restore","strokeStyle","stroke","fillStyle","fill","Array","isArray","_generateFillStyle","strokeText","offset","padding","Rectangle","debug","debugOptions","spans","enabled","bounding","beginPath","rect","baseline","moveTo","lineTo","closePath","top","bottom","toFixed","objects","updateTexture","result","wordWrapWidth","spaceLeft","tagSplit","firstWordOfLine","test","words","wordWidth","breakWords","characters","c","characterWidth","paddedWordWidth","_texture","hasLoaded","realWidth","realHeight","trim","frame","orig","_onTextureUpdate","emit","destination","_i","sources","sources_1","source","PI","fillGradientType","TEXT_GRADIENT","LINEAR_VERTICAL","fontFamily","fontStyle","fontVariant","fontWeight","lineHeight","miterLimit","Text"],"mappings":"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"}